function regenerarReferencias {
    # Preguntamos al usuario en qué idioma se encuentran los scripts las referencias
    mostrarIdiomasDisponibles

    echo "¿En qué idioma están los scripts?"
    echo -e -n "${AMARILLO}Código Idioma :${RESET}"
    read cod_idioma

    # Comprobamos si existe el código de idioma, si no existe, la función existeCodigoIdioma devuelve 1 si existe y 0 si no
    existeCodigoIdioma "$cod_idioma"
    existe=$? # Obtenemos el resultado del último comando ejecutado

    if [[ $existe -eq 1 ]]; then
        # Obtener los comentarios de cada script pero intentando ordenarlos y comprobar si nos han insertado alguno nuevo en medio
        for script in $(find */ -name "$FILTRO_FICHEROS" -type f); do
            # Obtenemos el nombre del fichero con 'basename' así no nos devuelve la ruta relativa del fichero.sh encontrado
            nombre_fichero=$(basename ${script%.*}) 
            directorio=$(dirname "$script")
            fichero_idioma="$directorio/${cod_idioma^^}_${nombre_fichero}.txt"

            echo "Código idioma: $cod_idioma"
            echo "Nombre fichero: $nombre_fichero"
            echo "Fichero idioma: $fichero_idioma"

            declare -a lineas_idiomas=()
            declare -a lineas_actualizada_script=()

            contador_lineas=$INICIO_NUM_LINEAS # Número inicial de cada línea

            while IFS= read -r linea; do
                # Comprobamos si cada línea es válida
                esLineaValidaComoComentario "$linea"
                linea_valida=$?

                if [[ $linea_valida -eq 1 ]]; then
                    echo "Línea válida: $linea"
                    # q for silence and E to enable regular expressions
                    if echo "$linea" | grep -qE '#[A-Z]+-[0-9]+-'; then
                        # cogemos todo lo que venga después del último -
                        linea_filtrada=$(echo "$linea" | cut -d'-' -f3-) # Desde field 3
                        # linea_filtrada=${linea##*-} Este puede fallar si hay más de 2 guiones
                        echo "Patrón Me quedé con: $linea_filtrada"
                    else
                        linea_filtrada=${linea#*#} # Cogemos todo lo que venga después de la primera # de la línea
                        echo "Me quedé con: $linea_filtrada"
                    fi

                    comentario="#"${cod_idioma^^}"-"$contador_lineas"-"$linea_filtrada
                    lineas_idiomas+=("$comentario")

                    # Escribimos el contenido en el fichero principal
                    if [[ "$linea" =~ ^# ]]; then
                        comentario_script="#"${cod_idioma^^}-${contador_lineas}-${linea_filtrada}
                    else
                        # Separamos la línea en la parte antes del primer # y el comentario después del #
                        parte_antes=${linea%%#*} # Partes antes de la referencia que puede ser cualquier código
                        comentario_despues=$(echo "$linea" | sed 's/^[A-Z]\+-[0-9]\+-//') # Si la línea es así #XX-YY-Comentario, quitamos el código de referencias
                        # Makes sense now : Cogemos la parte antes que no tiene # y luego la línea filtrada
                        comentario_script=${parte_antes}#${cod_idioma^^}-${contador_lineas}-${linea_filtrada}
                    fi    

                    lineas_actualizada_script+=("$comentario_script")
                    contador_lineas=$((contador_lineas + $INCR_LINEAS))
                else
                    # Seguimos a la siguiente línea
                    echo "Línea no válida: $linea"
                    comentario_script="$linea" # Unnecessary variable but just to make it clear for myself later on :)
                    lineas_actualizada_script+=("$comentario_script")
                    comentario=""
                    continue
                fi
            done < "$script"

            # Escribir en el fichero de idiomas y actualizar el script
            printf "%s\n" "${lineas_idiomas[@]}" > "$fichero_idioma"
            printf "%s\n" "${lineas_actualizada_script[@]}" > "$script"

            # Obtener el resto de los códigos de idiomas y actualizar sus ficheros con las nuevas referencias vacías
            local codigo_idiomas=() # Array para meter los códigos de idiomas

            while IFS= read -r linea; do
                linea_filtrada=${linea:1:2} # Obtenemos los valores del índice 1 y 2 de la línea, si la línea es #SP-Español, el índice 1:2 = SP
                # Añadimos cada código de idioma obtenido a un array
                codigo_idiomas+=("$linea_filtrada") # Añadimos cada código encontrado al array
            done < <(sed -n "$LINEA_INICIO_IDIOMAS,\$p" "${BASH_SOURCE}")

            for cod in ${codigo_idiomas[@]}; do
                if [[ "${cod,,}" != "${cod_idioma,,}" ]]; then
                    fichero_otro_idioma="$directorio/${cod}_${nombre_fichero}.txt"

                    # Leer el contenido existente del fichero
                    if [[ -f "$fichero_otro_idioma" ]]; then
                        mapfile -t lineas_otro_idioma < "$fichero_otro_idioma"
                    else
                        lineas_otro_idioma=()
                    fi

                    # Generar nuevas referencias manteniendo los comentarios existentes
                    nuevo_contador_lineas=$INICIO_NUM_LINEAS
                    for i in "${!lineas_otro_idioma[@]}"; do
                        if echo "${lineas_otro_idioma[$i]}" | grep -qE '#[A-Z]+-[0-9]+-'; then
                            comentario=$(echo "${lineas_otro_idioma[$i]}" | cut -d'-' -f3-)
                            lineas_otro_idioma[$i]="#${cod^^}-${nuevo_contador_lineas}-${comentario}"
                        fi
                        nuevo_contador_lineas=$((nuevo_contador_lineas + $INCR_LINEAS))
                    done

                    # Si el archivo de idioma es más corto que el archivo principal
                    while [[ $nuevo_contador_lineas -lt $contador_lineas ]]; do
                        lineas_otro_idioma+=("#${cod^^}-${nuevo_contador_lineas}-")
                        nuevo_contador_lineas=$((nuevo_contador_lineas + $INCR_LINEAS))
                    done

                    # Escribir el contenido actualizado en el fichero de otro idioma
                    printf "%s\n" "${lineas_otro_idioma[@]}" > "$fichero_otro_idioma"
                fi
            done
        done
    else
        mostrarErrorYAgregarloAlLogGeneral "No existe ese código de idioma" $FUNCNAME
        volverAlMenuOSalir
    fi    
} # Fin regenerarReferencias()

