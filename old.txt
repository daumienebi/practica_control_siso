#Cambiar el idioma de los comentarios de todos los scripts en los subdirectorios 
function cambiarIdiomaEnElScriptOld {
	#Volvemos a buscar los ficheros para encontrar cada script y dentro del ese mismo directorio, tenemos los ficheros de traducción
	find */ -name "$filtro_ficheros" -type f -print 
 	#Ahora por cada uno de ellos, cogemos su comentario y lo introducimos pero primero preguntamos el idioma
 	#Es necesario preguntar en que idioma se encuentran los ficheros?
 	#Preguntamos a que idioma lo quiere traducir el usuario
 	echo -e "\n¿A que idioma quieres traducir el script? (Indica el código [XY])"
 	mostrarIdiomasDisponibles
 	echo -e -n "${AMARILLO}Código Idioma:${RESET}"
 	read cod_idioma
 	#Comprobamos si existe el codigo de idioma, si no existe , la funcion devuelve 1 si existe y 0 si no
 	existeCodigoIdioma "${cod_idioma}"
 	existe=$? #Obtenemos el resultado del ultimo comando ejecutado
 	if [[ $existe -eq 1 ]]
 	then
 		#Ahora que existe el código, copiamos el las referencias del fichero al script
 		echo "Existe el codigo"
 		IFS=$'\n'
 		#Obtenemos cada sh de los subdirectorios
 		for script in $(find */ -name "$filtro_ficheros" -type f);
 		do
 			nombre_fichero=$(basename ${script%.*})
			ruta_fichero_original=$script
			directorio=$(dirname "$ruta_fichero_original")
			fichero_idioma="$directorio/${cod_idioma^^}_${nombre_fichero}.txt"
			#fichero_idioma=$cod_idioma"_"$nombre_fichero.txt
			echo $fichero_idioma
			echo $ruta_fichero_original
			#Con la opcion -r, nos aseguramos de que se lee todo tal cual aparece en el fichero y no se interprete de otra forma, por ejemplo el (\n o \t)
			#Leemos el fichero original y el fichero txt de traduccion pero primero miramos si existe el de traduccion
		 	if [[ -e "$fichero_idioma" ]]; then
		 	#Array para guardar las lineas
		 	declare -a lineas_referencias=()
		 	contenido_depues_de_guion=""
				while IFS= read -r linea_original; do
					esComentarioValido "$linea_original"
					valido=$?
					if [[ $valido -eq 1 ]]; then
						
						#if [[ "$linea_original" ==  aqui_va_la_condicion_para_ver_si_lo_que_se_lee esta en las referencias ]] then 
				    		#solo leemos si la linea es valida, para no perder lineas de traduccion del txt
				    		IFS= read -r linea_traduccion <&3
				    		linea_nueva="$linea_traduccion"
				    		echo "Linea original: $linea_original"
				   		echo "Linea traducida: $linea_traduccion"
				   		echo "Linea nueva: $linea_nueva"
				   		#Creo que no hace falta pillar solo lo que viene despues de -
				   		#contenido_depues_de_guion=${linea_traduccion##*-} maybe just when we are regenerating, we get everything after the last - as the line
				   		#if [[ -n $contenido_depues_de_guion ]]
				   		#then
				   		#	echo "Despues : $contenido_depues_de_guion"
				   		#	#Probamos un filtrado aqui por aqui por si hay lineas sin comentarios
				   		#	linea_nueva=#${contenido_depues_de_guion}
				   		#fi
					else
				    		linea_nueva="$linea_original"
				    		echo "Linea original: $linea_original"
				    		echo "Linea nueva: $linea_nueva"
					fi	
					# Añadimos la nueva línea al array
                    			lineas_referencias+=("$linea_nueva")
			    	done < "$ruta_fichero_original" 3< "$fichero_idioma"
			    	# Escribimos el contenido actualizado de nuevo en el archivo original
                		printf "%s\n" "${lineas_referencias[@]}" > "$ruta_fichero_original" #Risky shit :)
			else
			    echo -e "${ROJO}No se encontraron los ficheros de traducción correspondientes, puede que no estén generados${RESET}"
			    volverAlMenuOSalir
			fi
 		done
 		volverAlMenuOSalir
 	else
 		echo -e "${ROJO}No existe ese código de idioma${RESET}"
 		volverAlMenuOSalir
 	fi
} #Fin cambiarIdiomaEnElScriptOld()
